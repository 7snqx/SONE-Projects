<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dzielenie Plików Audio na Segmenty</title>
    <!-- FFmpeg scripts removed - using local implementation instead -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            /* Primitive Color Tokens */
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-gray-400: rgba(119, 124, 124, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-brown-600: rgba(94, 82, 64, 1);
            --color-charcoal-700: rgba(31, 33, 33, 1);
            --color-charcoal-800: rgba(38, 40, 40, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-400: rgba(45, 166, 178, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --color-teal-800: rgba(41, 150, 161, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-red-500: rgba(192, 21, 47, 1);
            --color-orange-400: rgba(230, 129, 97, 1);
            --color-orange-500: rgba(168, 75, 47, 1);

            /* RGB versions for opacity control */
            --color-brown-600-rgb: 94, 82, 64;
            --color-teal-500-rgb: 33, 128, 141;
            --color-slate-900-rgb: 19, 52, 59;
            --color-slate-500-rgb: 98, 108, 113;
            --color-red-500-rgb: 192, 21, 47;
            --color-red-400-rgb: 255, 84, 89;
            --color-orange-500-rgb: 168, 75, 47;
            --color-orange-400-rgb: 230, 129, 97;

            /* Background color tokens (Light Mode) */
            --color-bg-1: rgba(59, 130, 246, 0.08);
            --color-bg-2: rgba(245, 158, 11, 0.08);
            --color-bg-3: rgba(34, 197, 94, 0.08);
            --color-bg-4: rgba(239, 68, 68, 0.08);
            --color-bg-5: rgba(147, 51, 234, 0.08);
            --color-bg-6: rgba(249, 115, 22, 0.08);
            --color-bg-7: rgba(236, 72, 153, 0.08);
            --color-bg-8: rgba(6, 182, 212, 0.08);

            /* Semantic Color Tokens (Light Mode) */
            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-primary-active: var(--color-teal-700);
            --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
            --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
            --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
            --color-border: rgba(var(--color-brown-600-rgb), 0.2);
            --color-btn-primary-text: var(--color-cream-50);
            --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
            --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
            --color-error: var(--color-red-500);
            --color-success: var(--color-teal-500);
            --color-warning: var(--color-orange-500);
            --color-info: var(--color-slate-500);
            --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
            --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

            /* Common style patterns */
            --focus-ring: 0 0 0 3px var(--color-focus-ring);
            --focus-outline: 2px solid var(--color-primary);
            --status-bg-opacity: 0.15;
            --status-border-opacity: 0.25;
            --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

            /* RGB versions for opacity control */
            --color-success-rgb: 33, 128, 141;
            --color-error-rgb: 192, 21, 47;
            --color-warning-rgb: 168, 75, 47;
            --color-info-rgb: 98, 108, 113;

            /* Typography */
            --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            --font-size-xs: 11px;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-md: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 20px;
            --font-size-3xl: 24px;
            --font-size-4xl: 30px;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 550;
            --font-weight-bold: 600;
            --line-height-tight: 1.2;
            --line-height-normal: 1.5;
            --letter-spacing-tight: -0.01em;

            /* Spacing */
            --space-0: 0;
            --space-1: 1px;
            --space-2: 2px;
            --space-4: 4px;
            --space-6: 6px;
            --space-8: 8px;
            --space-10: 10px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --space-32: 32px;

            /* Border Radius */
            --radius-sm: 6px;
            --radius-base: 8px;
            --radius-md: 10px;
            --radius-lg: 12px;
            --radius-full: 9999px;

            /* Shadows */
            --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04), 0 4px 6px -2px rgba(0, 0, 0, 0.02);
            --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15), inset 0 -1px 0 rgba(0, 0, 0, 0.03);

            /* Animation */
            --duration-fast: 150ms;
            --duration-normal: 250ms;
            --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

            /* Layout */
            --container-sm: 640px;
            --container-md: 768px;
            --container-lg: 1024px;
            --container-xl: 1280px;
        }

        /* Dark mode colors */
        @media (prefers-color-scheme: dark) {
            :root {
                --color-gray-400-rgb: 119, 124, 124;
                --color-teal-300-rgb: 50, 184, 198;
                --color-gray-300-rgb: 167, 169, 169;
                --color-gray-200-rgb: 245, 245, 245;

                --color-bg-1: rgba(29, 78, 216, 0.15);
                --color-bg-2: rgba(180, 83, 9, 0.15);
                --color-bg-3: rgba(21, 128, 61, 0.15);
                --color-bg-4: rgba(185, 28, 28, 0.15);
                --color-bg-5: rgba(107, 33, 168, 0.15);
                --color-bg-6: rgba(194, 65, 12, 0.15);
                --color-bg-7: rgba(190, 24, 93, 0.15);
                --color-bg-8: rgba(8, 145, 178, 0.15);

                --color-background: var(--color-charcoal-700);
                --color-surface: var(--color-charcoal-800);
                --color-text: var(--color-gray-200);
                --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
                --color-primary: var(--color-teal-300);
                --color-primary-hover: var(--color-teal-400);
                --color-primary-active: var(--color-teal-800);
                --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
                --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
                --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
                --color-border: rgba(var(--color-gray-400-rgb), 0.3);
                --color-error: var(--color-red-400);
                --color-success: var(--color-teal-300);
                --color-warning: var(--color-orange-400);
                --color-info: var(--color-gray-300);
                --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
                --color-btn-primary-text: var(--color-slate-900);
                --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
                --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
                --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1), inset 0 -1px 0 rgba(0, 0, 0, 0.15);
                --button-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
                --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
                --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

                --color-success-rgb: var(--color-teal-300-rgb);
                --color-error-rgb: var(--color-red-400-rgb);
                --color-warning-rgb: var(--color-orange-400-rgb);
                --color-info-rgb: var(--color-gray-300-rgb);
            }
        }

        /* Base styles */
        html {
            font-size: var(--font-size-base);
            font-family: var(--font-family-base);
            line-height: var(--line-height-normal);
            color: var(--color-text);
            background-color: var(--color-background);
            -webkit-font-smoothing: antialiased;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
        }

        *, *::before, *::after {
            box-sizing: inherit;
        }

        /* Typography */
        h1, h2, h3, h4, h5, h6 {
            margin: 0;
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-tight);
            color: var(--color-text);
            letter-spacing: var(--letter-spacing-tight);
        }

        h1 { font-size: var(--font-size-4xl); }
        h2 { font-size: var(--font-size-3xl); }
        h3 { font-size: var(--font-size-2xl); }
        h4 { font-size: var(--font-size-xl); }
        h5 { font-size: var(--font-size-lg); }
        h6 { font-size: var(--font-size-md); }

        p {
            margin: 0 0 var(--space-16) 0;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-8) var(--space-16);
            border-radius: var(--radius-base);
            font-size: var(--font-size-base);
            font-weight: 500;
            line-height: 1.5;
            cursor: pointer;
            transition: all var(--duration-normal) var(--ease-standard);
            border: none;
            text-decoration: none;
            position: relative;
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        .btn--primary {
            background: var(--color-primary);
            color: var(--color-btn-primary-text);
        }

        .btn--primary:hover {
            background: var(--color-primary-hover);
        }

        .btn--primary:active {
            background: var(--color-primary-active);
        }

        .btn--secondary {
            background: var(--color-secondary);
            color: var(--color-text);
        }

        .btn--secondary:hover {
            background: var(--color-secondary-hover);
        }

        .btn--secondary:active {
            background: var(--color-secondary-active);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn--full-width {
            width: 100%;
        }

        /* Form elements */
        .form-control {
            display: block;
            width: 100%;
            padding: var(--space-8) var(--space-12);
            font-size: var(--font-size-md);
            line-height: 1.5;
            color: var(--color-text);
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            transition: border-color var(--duration-fast) var(--ease-standard), box-shadow var(--duration-fast) var(--ease-standard);
        }

        select.form-control {
            padding: var(--space-8) var(--space-12);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: var(--select-caret-light);
            background-repeat: no-repeat;
            background-position: right var(--space-12) center;
            background-size: 16px;
            padding-right: var(--space-32);
        }

        @media (prefers-color-scheme: dark) {
            select.form-control {
                background-image: var(--select-caret-dark);
            }
        }

        .form-control:focus {
            border-color: var(--color-primary);
            outline: var(--focus-outline);
        }

        .form-label {
            display: block;
            margin-bottom: var(--space-8);
            font-weight: var(--font-weight-medium);
            font-size: var(--font-size-sm);
        }

        .form-group {
            margin-bottom: var(--space-16);
        }

        /* Card component */
        .card {
            background-color: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-card-border);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: box-shadow var(--duration-normal) var(--ease-standard);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
        }

        .card__body {
            padding: var(--space-16);
        }

        .card__header {
            padding: var(--space-16);
            border-bottom: 1px solid var(--color-card-border-inner);
        }

        /* Status indicators */
        .status {
            display: inline-flex;
            align-items: center;
            padding: var(--space-6) var(--space-12);
            border-radius: var(--radius-full);
            font-weight: var(--font-weight-medium);
            font-size: var(--font-size-sm);
        }

        .status--success {
            background-color: rgba(var(--color-success-rgb), var(--status-bg-opacity));
            color: var(--color-success);
            border: 1px solid rgba(var(--color-success-rgb), var(--status-border-opacity));
        }

        .status--error {
            background-color: rgba(var(--color-error-rgb), var(--status-bg-opacity));
            color: var(--color-error);
            border: 1px solid rgba(var(--color-error-rgb), var(--status-border-opacity));
        }

        .status--warning {
            background-color: rgba(var(--color-warning-rgb), var(--status-bg-opacity));
            color: var(--color-warning);
            border: 1px solid rgba(var(--color-warning-rgb), var(--status-border-opacity));
        }

        .status--info {
            background-color: rgba(var(--color-info-rgb), var(--status-bg-opacity));
            color: var(--color-info);
            border: 1px solid rgba(var(--color-info-rgb), var(--status-border-opacity));
        }

        /* Container layout */
        .container {
            width: 100%;
            margin-right: auto;
            margin-left: auto;
            padding-right: var(--space-16);
            padding-left: var(--space-16);
        }

        @media (min-width: 640px) { .container { max-width: var(--container-sm); } }
        @media (min-width: 768px) { .container { max-width: var(--container-md); } }
        @media (min-width: 1024px) { .container { max-width: var(--container-lg); } }
        @media (min-width: 1280px) { .container { max-width: var(--container-xl); } }

        /* Utility classes */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .gap-4 { gap: var(--space-4); }
        .gap-8 { gap: var(--space-8); }
        .gap-16 { gap: var(--space-16); }
        .mt-8 { margin-top: var(--space-8); }
        .mb-8 { margin-bottom: var(--space-8); }
        .py-16 { padding-top: var(--space-16); padding-bottom: var(--space-16); }
        .px-16 { padding-left: var(--space-16); padding-right: var(--space-16); }
        .block { display: block; }
        .hidden { display: none; }

        /* Custom styles for audio splitter */
        .upload-area {
            border: 2px dashed var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-32);
            text-align: center;
            transition: all var(--duration-normal) var(--ease-standard);
            cursor: pointer;
            background: var(--color-bg-1);
        }

        .upload-area:hover {
            border-color: var(--color-primary);
            background: var(--color-bg-2);
        }

        .upload-area.dragover {
            border-color: var(--color-primary);
            background: var(--color-bg-3);
        }

        .file-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-16);
            margin: var(--space-16) 0;
        }

        .segments-preview {
            margin: var(--space-16) 0;
        }

        .segment-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-12);
            margin-bottom: var(--space-8);
            background: var(--color-bg-4);
            border-radius: var(--radius-base);
            border: 1px solid var(--color-card-border);
        }

        .progress-bar {
            width: 100%;
            height: var(--space-8);
            background: var(--color-secondary);
            border-radius: var(--radius-full);
            overflow: hidden;
            margin: var(--space-16) 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--color-primary);
            width: 0%;
            transition: width var(--duration-normal) var(--ease-standard);
        }

        .download-section {
            margin-top: var(--space-24);
        }

        .download-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-12);
            margin-bottom: var(--space-8);
            background: var(--color-bg-5);
            border-radius: var(--radius-base);
            border: 1px solid var(--color-card-border);
        }

        .loading-message {
            text-align: center;
            padding: var(--space-20);
            font-style: italic;
            color: var(--color-text-secondary);
        }

        .error-message {
            padding: var(--space-12);
            background: rgba(var(--color-error-rgb), 0.1);
            color: var(--color-error);
            border: 1px solid rgba(var(--color-error-rgb), 0.2);
            border-radius: var(--radius-base);
            margin: var(--space-16) 0;
        }

        .success-message {
            padding: var(--space-12);
            background: rgba(var(--color-success-rgb), 0.1);
            color: var(--color-success);
            border: 1px solid rgba(var(--color-success-rgb), 0.2);
            border-radius: var(--radius-base);
            margin: var(--space-16) 0;
        }

        /* Radio button styling */
        input[type="radio"] {
            width: var(--space-16);
            height: var(--space-16);
            margin: 0;
            margin-right: var(--space-8);
            accent-color: var(--color-primary);
            cursor: pointer;
        }
        
        .quick-size-buttons {
            display: flex;
            gap: var(--space-8);
            flex-wrap: wrap;
        }
        
        .quick-size-buttons .btn {
            padding: var(--space-6) var(--space-12);
            font-size: var(--font-size-sm);
        }
        
        .segment-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-16);
            padding-bottom: var(--space-8);
            border-bottom: 1px solid var(--color-border);
        }
        
        .preview-mode-indicator {
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
            font-style: italic;
        }
        
        .warning-segment {
            border-left: 3px solid var(--color-warning);
        }

        @font-face {
            font-family: 'FKGroteskNeue';
            src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2') format('woff2');
        }
    </style>
</head>
<body>
    <div class="container py-16">
        <h1 style="text-align: center; margin-bottom: var(--space-32);">Dzielenie Plików Audio na Segmenty</h1>
        
        <!-- Audio Engine Status -->
        <div id="engine-status" class="loading-message">
            <div class="status status--info">Inicjalizacja silnika audio...</div>
        </div>

        <!-- Engine Mode Info -->
        <div class="card" id="engine-info" style="display: none;">
            <div class="card__body">
                <div class="flex justify-between items-center">
                    <div>
                        <strong>Aktywny silnik:</strong>
                        <span id="active-engine">Web Audio API</span>
                    </div>
                    <div class="status status--info" id="engine-limitations">
                        Wyjście: format WAV
                    </div>
                </div>
            </div>
        </div>

        <!-- Upload Area -->
        <div class="card" id="upload-section" style="display: none;">
            <div class="card__body">
                <div class="upload-area" id="upload-area">
                    <h3>Przeciągnij plik audio tutaj lub kliknij, aby wybrać</h3>
                    <p>Obsługiwane formaty wejściowe: MP3, WAV, M4A, FLAC, OGG, AAC</p>
                    <p><small>Format wyjściowy: WAV (uniwersalne wsparcie)</small></p>
                    <input type="file" id="file-input" accept="audio/*" style="display: none;">
                </div>
            </div>
        </div>

        <!-- File Information -->
        <div class="card" id="file-info-section" style="display: none;">
            <div class="card__header">
                <h3>Informacje o pliku</h3>
            </div>
            <div class="card__body">
                <div class="file-info">
                    <div>
                        <strong>Nazwa pliku:</strong>
                        <div id="file-name">-</div>
                    </div>
                    <div>
                        <strong>Rozmiar:</strong>
                        <div id="file-size">-</div>
                    </div>
                    <div>
                        <strong>Długość:</strong>
                        <div id="file-duration">-</div>
                    </div>
                    <div>
                        <strong>Format:</strong>
                        <div id="file-format">-</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Segment Selection -->
        <div class="card" id="segment-section" style="display: none;">
            <div class="card__header">
                <h3>Wybierz sposób podziału</h3>
            </div>
            <div class="card__body">
                <!-- Mode Selection -->
                <div class="form-group">
                    <label class="form-label">Tryb podziału:</label>
                    <div class="flex gap-16" style="margin-bottom: var(--space-16);">
                        <label class="flex items-center gap-8" style="cursor: pointer;">
                            <input type="radio" name="split-mode" value="equal" id="mode-equal" checked>
                            <span>Równe segmenty czasowe</span>
                        </label>
                        <label class="flex items-center gap-8" style="cursor: pointer;">
                            <input type="radio" name="split-mode" value="size" id="mode-size">
                            <span>Limit rozmiaru pliku</span>
                        </label>
                    </div>
                </div>
                
                <!-- Equal Segments Mode -->
                <div id="equal-mode-controls">
                    <div class="form-group">
                        <label for="segments-select" class="form-label">Liczba segmentów:</label>
                        <select id="segments-select" class="form-control">
                            <option value="2">2 segmenty</option>
                            <option value="3">3 segmenty</option>
                            <option value="4">4 segmenty</option>
                            <option value="5">5 segmentów</option>
                            <option value="6">6 segmentów</option>
                            <option value="8">8 segmentów</option>
                            <option value="10">10 segmentów</option>
                            <option value="12">12 segmentów</option>
                            <option value="15">15 segmentów</option>
                            <option value="20">20 segmentów</option>
                        </select>
                    </div>
                </div>
                
                <!-- Size Limit Mode -->
                <div id="size-mode-controls" style="display: none;">
                    <div class="form-group">
                        <label for="max-size-input" class="form-label">Maksymalny rozmiar segmentu (MB):</label>
                        <input type="number" id="max-size-input" class="form-control" min="10" max="5000" value="200" placeholder="Wpisz rozmiar w MB">
                        <div class="error-message" id="size-error" style="display: none; margin-top: var(--space-8); padding: var(--space-8);"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Szybki wybór:</label>
                        <div class="quick-size-buttons">
                            <button type="button" class="btn btn--secondary" onclick="audioSplitter.setMaxSize(25)">25 MB</button>
                            <button type="button" class="btn btn--secondary" onclick="audioSplitter.setMaxSize(50)">50 MB</button>
                            <button type="button" class="btn btn--secondary" onclick="audioSplitter.setMaxSize(100)">100 MB</button>
                            <button type="button" class="btn btn--secondary" onclick="audioSplitter.setMaxSize(200)">200 MB</button>
                            <button type="button" class="btn btn--secondary" onclick="audioSplitter.setMaxSize(500)">500 MB</button>
                            <button type="button" class="btn btn--secondary" onclick="audioSplitter.setMaxSize(1000)">1000 MB</button>
                        </div>
                    </div>
                    <div id="calculated-segments" class="status status--info" style="margin: var(--space-16) 0; display: none;">
                        <span id="segments-count-text">Obliczanie...</span>
                    </div>
                </div>
                
                <button class="btn btn--primary btn--full-width" id="split-button">Podziel Audio</button>
            </div>
        </div>

        <!-- Segments Preview -->
        <div class="card" id="preview-section" style="display: none;">
            <div class="card__header">
                <div class="segment-preview-header">
                    <h3>Podgląd segmentów</h3>
                    <div class="preview-mode-indicator" id="preview-mode-indicator"></div>
                </div>
            </div>
            <div class="card__body">
                <div id="segments-preview"></div>
            </div>
        </div>

        <!-- Processing Status -->
        <div id="processing-section" style="display: none;">
            <div class="card">
                <div class="card__body">
                    <h3>Przetwarzanie...</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div id="processing-status">Rozpoczynanie...</div>
                </div>
            </div>
        </div>

        <!-- Download Section -->
        <div class="card" id="download-section" style="display: none;">
            <div class="card__header">
                <h3>Pobierz segmenty</h3>
            </div>
            <div class="card__body">
                <div class="success-message">
                    Podział zakończony pomyślnie! Możesz teraz pobrać poszczególne segmenty.
                </div>
                <div id="download-list"></div>
                <button class="btn btn--secondary btn--full-width mt-8" id="download-all-button">Pobierz folder z segmentami (ZIP)</button>
                <button class="btn btn--primary btn--full-width mt-8" id="new-file-button">Przetwórz nowy plik</button>
            </div>
        </div>

        <!-- Error Messages -->
        <div id="error-section" style="display: none;">
            <div class="error-message" id="error-message"></div>
        </div>
    </div>

    <script>
        class AudioSplitter {
            constructor() {
                this.audioContext = null;
                this.currentFile = null;
                this.currentDuration = 0;
                this.currentFileSize = 0;
                this.currentBitrate = 0;
                this.segments = [];
                this.processedSegments = [];
                this.splitMode = 'equal';
                this.maxSizeMB = 200;
                this.engineMode = 'webaudio'; // Always use Web Audio API
                
                this.initializeAudioEngine();
                this.initializeEventListeners();
            }

            async initializeAudioEngine() {
                try {
                    // Initialize Web Audio API
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    this.showStatus('Web Audio API zainicjalizowany pomyślnie!', 'success');
                    document.getElementById('active-engine').textContent = 'Web Audio API';
                    document.getElementById('engine-limitations').textContent = 'Wyjście: format WAV';
                    document.getElementById('engine-info').style.display = 'block';
                    document.getElementById('upload-section').style.display = 'block';
                } catch (error) {
                    console.error('Błąd podczas inicjalizacji Web Audio API:', error);
                    this.showError('Twoja przeglądarka nie obsługuje Web Audio API. Spróbuj użyć nowszej przeglądarki.');
                }
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('upload-area');
                const fileInput = document.getElementById('file-input');
                const segmentsSelect = document.getElementById('segments-select');
                const splitButton = document.getElementById('split-button');
                const downloadAllButton = document.getElementById('download-all-button');
                const newFileButton = document.getElementById('new-file-button');
                const modeRadios = document.querySelectorAll('input[name="split-mode"]');
                const maxSizeInput = document.getElementById('max-size-input');

                // Upload area click
                uploadArea.addEventListener('click', () => fileInput.click());

                // File input change
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files[0]));

                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFileSelect(e.dataTransfer.files[0]);
                });

                // Mode selection change
                modeRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.splitMode = e.target.value;
                        this.updateModeControls();
                        this.updateSegmentsPreview();
                    });
                });

                // Segments selection change
                segmentsSelect.addEventListener('change', () => this.updateSegmentsPreview());
                
                // Max size input change
                maxSizeInput.addEventListener('input', () => {
                    this.validateMaxSize();
                    this.updateSegmentsPreview();
                });

                // Split button
                splitButton.addEventListener('click', () => this.splitAudio());

                // Download all button
                downloadAllButton.addEventListener('click', () => this.downloadAllSegments());

                // New file button
                newFileButton.addEventListener('click', () => this.resetApplication());
            }

            async handleFileSelect(file) {
                if (!file) return;

                // Validate file type
                const supportedFormats = ['mp3', 'wav', 'm4a', 'flac', 'ogg', 'aac', 'wma'];
                const fileExtension = file.name.split('.').pop().toLowerCase();
                
                if (!supportedFormats.includes(fileExtension)) {
                    this.showError('Nieobsługiwany format pliku. Obsługiwane formaty: MP3, WAV, M4A, FLAC, OGG, AAC, WMA');
                    return;
                }

                this.currentFile = file;
                this.currentFileSize = file.size;
                
                // Show file info
                this.displayFileInfo(file);
                
                try {
                    // Get audio duration
                    const duration = await this.getAudioDuration(file);
                    this.currentDuration = duration;
                    
                    // Calculate bitrate
                    this.currentBitrate = (this.currentFileSize * 8) / duration;
                    
                    document.getElementById('file-duration').textContent = this.formatDuration(duration);
                    document.getElementById('segment-section').style.display = 'block';
                    
                    this.updateModeControls();
                    this.updateSegmentsPreview();
                } catch (error) {
                    console.error('Błąd podczas analizy pliku:', error);
                    this.showError('Nie udało się przeanalizować pliku audio.');
                }
            }

            displayFileInfo(file) {
                document.getElementById('file-name').textContent = file.name;
                document.getElementById('file-size').textContent = this.formatFileSize(file.size);
                document.getElementById('file-format').textContent = file.type || 'Nieznany';
                document.getElementById('file-info-section').style.display = 'block';
            }

            async getAudioDuration(file) {
                return new Promise((resolve, reject) => {
                    const audio = new Audio();
                    const url = URL.createObjectURL(file);
                    
                    audio.addEventListener('loadedmetadata', () => {
                        URL.revokeObjectURL(url);
                        resolve(audio.duration);
                    });
                    
                    audio.addEventListener('error', () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Nie udało się odczytać metadanych audio'));
                    });
                    
                    audio.src = url;
                });
            }

            updateModeControls() {
                const equalControls = document.getElementById('equal-mode-controls');
                const sizeControls = document.getElementById('size-mode-controls');
                
                if (this.splitMode === 'equal') {
                    equalControls.style.display = 'block';
                    sizeControls.style.display = 'none';
                } else {
                    equalControls.style.display = 'none';
                    sizeControls.style.display = 'block';
                    this.updateCalculatedSegments();
                }
            }
            
            setMaxSize(sizeMB) {
                document.getElementById('max-size-input').value = sizeMB;
                this.maxSizeMB = sizeMB;
                this.validateMaxSize();
                this.updateSegmentsPreview();
            }
            
            validateMaxSize() {
                const input = document.getElementById('max-size-input');
                const errorDiv = document.getElementById('size-error');
                const value = parseInt(input.value);
                
                if (isNaN(value) || value < 10) {
                    errorDiv.textContent = 'Minimalna wielkość segmentu to 10 MB';
                    errorDiv.style.display = 'block';
                    return false;
                } else if (value > 5000) {
                    errorDiv.textContent = 'Maksymalna wielkość segmentu to 5000 MB';
                    errorDiv.style.display = 'block';
                    return false;
                } else {
                    errorDiv.style.display = 'none';
                    this.maxSizeMB = value;
                    this.updateCalculatedSegments();
                    return true;
                }
            }
            
            updateCalculatedSegments() {
                if (this.splitMode === 'size' && this.currentBitrate > 0) {
                    const maxSizeInBits = this.maxSizeMB * 8 * 1024 * 1024;
                    const maxSegmentDuration = maxSizeInBits / this.currentBitrate;
                    const numberOfSegments = Math.ceil(this.currentDuration / maxSegmentDuration);
                    
                    const calculatedDiv = document.getElementById('calculated-segments');
                    const textSpan = document.getElementById('segments-count-text');
                    
                    if (numberOfSegments === 1) {
                        textSpan.textContent = `Plik zmieści się w 1 segmencie (${this.formatFileSize(this.currentFileSize)})`;
                    } else {
                        textSpan.textContent = `Zostanie utworzonych ${numberOfSegments} segmentów`;
                    }
                    
                    calculatedDiv.style.display = 'block';
                }
            }

            updateSegmentsPreview() {
                if (!this.currentFile || this.currentDuration === 0) return;
                
                const baseName = this.currentFile.name.replace(/\.[^/.]+$/, "");
                // Always use .wav extension for Web Audio API output
                const extension = 'wav';
                
                this.segments = [];
                let previewHtml = '';
                
                if (this.splitMode === 'equal') {
                    // Equal time segments
                    const numSegments = parseInt(document.getElementById('segments-select').value);
                    const segmentDuration = this.currentDuration / numSegments;
                    
                    for (let i = 0; i < numSegments; i++) {
                        const startTime = i * segmentDuration;
                        const endTime = Math.min((i + 1) * segmentDuration, this.currentDuration);
                        const segmentName = `${baseName} part ${i + 1}.wav`;
                        
                        this.segments.push({
                            name: segmentName,
                            startTime: startTime,
                            endTime: endTime,
                            duration: endTime - startTime
                        });
                        
                        previewHtml += `
                            <div class="segment-item">
                                <div>
                                    <strong>${segmentName}</strong><br>
                                    <small>${this.formatDuration(startTime)} - ${this.formatDuration(endTime)}</small>
                                </div>
                                <div class="status status--info">
                                    ${this.formatDuration(endTime - startTime)}
                                </div>
                            </div>
                        `;
                    }
                } else {
                    // Size-based segments
                    if (!this.validateMaxSize()) {
                        document.getElementById('preview-section').style.display = 'none';
                        return;
                    }
                    
                    const maxSizeInBits = this.maxSizeMB * 8 * 1024 * 1024;
                    const maxSegmentDuration = maxSizeInBits / this.currentBitrate;
                    const numberOfSegments = Math.ceil(this.currentDuration / maxSegmentDuration);
                    
                    for (let i = 0; i < numberOfSegments; i++) {
                        const startTime = i * maxSegmentDuration;
                        const endTime = Math.min((i + 1) * maxSegmentDuration, this.currentDuration);
                        const segmentDuration = endTime - startTime;
                        const segmentName = `${baseName} part ${i + 1}.wav`;
                        
                        // Calculate estimated size
                        const estimatedSizeInBits = segmentDuration * this.currentBitrate;
                        const estimatedSizeInBytes = estimatedSizeInBits / 8;
                        
                        this.segments.push({
                            name: segmentName,
                            startTime: startTime,
                            endTime: endTime,
                            duration: segmentDuration
                        });
                        
                        // Check if this is the last segment and significantly smaller
                        const isLastSegment = i === numberOfSegments - 1;
                        const isSmallLastSegment = isLastSegment && numberOfSegments > 1 && segmentDuration < (maxSegmentDuration * 0.3);
                        
                        previewHtml += `
                            <div class="segment-item${isSmallLastSegment ? ' warning-segment' : ''}">
                                <div>
                                    <strong>${segmentName}</strong><br>
                                    <small>${this.formatDuration(startTime)} - ${this.formatDuration(endTime)}</small>
                                    ${isSmallLastSegment ? '<br><small style="color: var(--color-warning);">⚠ Mały ostatni segment</small>' : ''}
                                </div>
                                <div>
                                    <div class="status status--info">
                                        ${this.formatDuration(segmentDuration)}
                                    </div>
                                    <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">
                                        ~${this.formatFileSize(estimatedSizeInBytes)} (WAV)
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }
                
                document.getElementById('segments-preview').innerHTML = previewHtml;
                
                // Update preview mode indicator
                const indicator = document.getElementById('preview-mode-indicator');
                if (this.splitMode === 'equal') {
                    indicator.textContent = 'Równe segmenty czasowe (format WAV)';
                } else {
                    indicator.textContent = `Maksymalnie ${this.maxSizeMB} MB na segment (format WAV)`;
                }
                
                document.getElementById('preview-section').style.display = 'block';
            }

            async splitAudio() {
                if (!this.audioContext || !this.currentFile || this.segments.length === 0) {
                    this.showError('Brak pliku do przetworzenia lub błąd inicjalizacji.');
                    return;
                }
                
                // Additional validation for size mode
                if (this.splitMode === 'size' && !this.validateMaxSize()) {
                    this.showError('Sprawdź ustawienia rozmiaru segmentu.');
                    return;
                }

                try {
                    document.getElementById('processing-section').style.display = 'block';
                    document.getElementById('segment-section').style.display = 'none';
                    document.getElementById('preview-section').style.display = 'none';
                    
                    this.updateProgress(10, 'Dekodowanie pliku audio...');
                    
                    // Load and decode audio file
                    const arrayBuffer = await this.currentFile.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    this.updateProgress(30, 'Przygotowanie segmentów...');
                    
                    this.processedSegments = [];
                    const sampleRate = audioBuffer.sampleRate;
                    
                    // Process each segment
                    for (let i = 0; i < this.segments.length; i++) {
                        const segment = this.segments[i];
                        
                        this.updateProgress(
                            30 + (i / this.segments.length) * 60,
                            `Tworzenie segmentu ${i + 1} z ${this.segments.length}...`
                        );
                        
                        // Calculate sample positions
                        const startSample = Math.floor(segment.startTime * sampleRate);
                        const endSample = Math.floor(segment.endTime * sampleRate);
                        const segmentLength = endSample - startSample;
                        
                        // Create new AudioBuffer for this segment
                        const segmentBuffer = this.audioContext.createBuffer(
                            audioBuffer.numberOfChannels,
                            segmentLength,
                            sampleRate
                        );
                        
                        // Copy audio data for each channel
                        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                            const originalChannelData = audioBuffer.getChannelData(channel);
                            const segmentChannelData = segmentBuffer.getChannelData(channel);
                            
                            for (let sample = 0; sample < segmentLength; sample++) {
                                if (startSample + sample < originalChannelData.length) {
                                    segmentChannelData[sample] = originalChannelData[startSample + sample];
                                }
                            }
                        }
                        
                        // Convert AudioBuffer to WAV
                        const wavBlob = this.audioBufferToWav(segmentBuffer);
                        
                        // Create filename with .wav extension
                        const baseName = this.currentFile.name.replace(/\.[^/.]+$/, "");
                        const segmentName = `${baseName} part ${i + 1}.wav`;
                        
                        this.processedSegments.push({
                            name: segmentName,
                            blob: wavBlob,
                            url: URL.createObjectURL(wavBlob)
                        });
                    }
                    
                    this.updateProgress(100, 'Przetwarzanie zakończone!');
                    
                    setTimeout(() => {
                        document.getElementById('processing-section').style.display = 'none';
                        this.showDownloadSection();
                    }, 1000);
                    
                } catch (error) {
                    console.error('Błąd podczas dzielenia audio:', error);
                    this.showError('Błąd podczas przetwarzania audio: ' + error.message);
                    document.getElementById('processing-section').style.display = 'none';
                }
            }

            showDownloadSection() {
                let downloadHtml = '';
                
                this.processedSegments.forEach((segment, index) => {
                    downloadHtml += `
                        <div class="download-item">
                            <div>
                                <strong>${segment.name}</strong><br>
                                <small>Segment ${index + 1}</small>
                            </div>
                            <button class="btn btn--secondary" onclick="audioSplitter.downloadSegment(${index})">
                                Pobierz
                            </button>
                        </div>
                    `;
                });
                
                document.getElementById('download-list').innerHTML = downloadHtml;
                document.getElementById('download-section').style.display = 'block';
            }

            downloadSegment(index) {
                const segment = this.processedSegments[index];
                const a = document.createElement('a');
                a.href = segment.url;
                a.download = segment.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

    downloadAllSegments() {
        if (!this.processedSegments.length) return;
        
        // Create a new ZIP file
        const zip = new JSZip();
        
        // Get the base name of the original file (without extension) for the folder
        const originalFileName = this.currentFile.name;
        const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
        const folderName = baseName;
        
        // Add all segments to the ZIP in a folder
        this.processedSegments.forEach((segment, index) => {
            // Add each segment file to the folder in the ZIP
            zip.file(`${folderName}/${segment.name}`, segment.blob);
        });
        
        // Generate and download the ZIP file
        zip.generateAsync({type:"blob"}).then(function(content) {
            const a = document.createElement('a');
            const url = URL.createObjectURL(content);
            a.href = url;
            a.download = `${folderName}_segments.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    }

            resetApplication() {
                // Clean up URLs
                this.processedSegments.forEach(segment => {
                    if (segment.url) {
                        URL.revokeObjectURL(segment.url);
                    }
                });
                
                // Reset state
                this.currentFile = null;
                this.currentDuration = 0;
                this.currentFileSize = 0;
                this.currentBitrate = 0;
                this.segments = [];
                this.processedSegments = [];
                this.splitMode = 'equal';
                this.maxSizeMB = 200;
                
                // Reset form inputs
                document.getElementById('mode-equal').checked = true;
                document.getElementById('max-size-input').value = '200';
                document.getElementById('size-error').style.display = 'none';
                document.getElementById('calculated-segments').style.display = 'none';
                
                // Reset mode controls
                this.updateModeControls();
                
                // Hide sections
                document.getElementById('file-info-section').style.display = 'none';
                document.getElementById('segment-section').style.display = 'none';
                document.getElementById('preview-section').style.display = 'none';
                document.getElementById('processing-section').style.display = 'none';
                document.getElementById('download-section').style.display = 'none';
                document.getElementById('error-section').style.display = 'none';
                
                // Reset file input
                document.getElementById('file-input').value = '';
                
                // Show upload section
                document.getElementById('upload-section').style.display = 'block';
            }

            updateProgress(percentage, message) {
                document.getElementById('progress-fill').style.width = percentage + '%';
                document.getElementById('processing-status').textContent = message;
            }

            audioBufferToWav(buffer) {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const bitsPerSample = 16;
                const bytesPerSample = bitsPerSample / 8;
                const byteRate = sampleRate * numberOfChannels * bytesPerSample;
                const blockAlign = numberOfChannels * bytesPerSample;
                const dataLength = length * numberOfChannels * bytesPerSample;
                const fileLength = 44 + dataLength;
                
                const arrayBuffer = new ArrayBuffer(fileLength);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, fileLength - 8, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // PCM format
                view.setUint16(20, 1, true); // PCM
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitsPerSample, true);
                writeString(36, 'data');
                view.setUint32(40, dataLength, true);
                
                // Convert audio data to 16-bit PCM
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, intSample, true);
                        offset += 2;
                    }
                }
                
                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            showStatus(message, type = 'info') {
                const statusDiv = document.getElementById('engine-status');
                statusDiv.innerHTML = `<div class="status status--${type}">${message}</div>`;
                
                if (type === 'success') {
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                    }, 2000);
                }
            }

            showError(message) {
                document.getElementById('error-message').textContent = message;
                document.getElementById('error-section').style.display = 'block';
                
                setTimeout(() => {
                    document.getElementById('error-section').style.display = 'none';
                }, 5000);
            }

            formatDuration(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                } else {
                    return `${minutes}:${secs.toString().padStart(2, '0')}`;
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Initialize the application
        const audioSplitter = new AudioSplitter();
    </script>
</body>
</html>